use futures::{future, prelude::*};
use std::net::SocketAddr;

use tarpc::{
    context,
    server::{self, Channel},
    tokio_serde::formats::Json,
};

#[tarpc::service]
pub trait MyProtocol {
    async fn ping() -> ();
}

#[derive(Clone)]
struct MyServer {
    forwarding_client: Option<MyProtocolClient>,
}

#[tarpc::server]
impl MyProtocol for MyServer {
    async fn ping(self, _: context::Context) -> () {
        match self.forwarding_client {
            Some(client) => client.ping(context::current()).await.unwrap(),
            None => {
                println!("received ping");
                //simulates disk operation in my real database
                tokio::time::sleep(std::time::Duration::from_millis(10)).await;
                println!("done sleeping");
            }
        }
    }
}

pub async fn run_server() {
    let host_address: SocketAddr = std::env::args().nth(1).unwrap().parse().unwrap();

    console_subscriber::ConsoleLayer::builder()
    .server_addr(([127, 0, 0, 1], host_address.port() + 1))
    .init();

    let forwarding_client: Option<MyProtocolClient> = match std::env::args().nth(2) {
        Some(addr) => {
            let addr: SocketAddr = addr.parse().unwrap();
            let transport = tarpc::serde_transport::tcp::connect(addr, Json::default);
            Some(
                MyProtocolClient::new(tarpc::client::Config::default(), transport.await.unwrap())
                    .spawn(),
            )
        }
        None => None,
    };

    let server = MyServer { forwarding_client };
    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    let mut listener = tarpc::serde_transport::tcp::listen(host_address, Json::default)
        .await
        .expect("starting tarpc server failed");
    listener.config_mut().max_frame_length(4294967296);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| channel.execute(server.clone().serve()))
        .buffer_unordered(50)
        .for_each(|_| async {})
        .await;
}
